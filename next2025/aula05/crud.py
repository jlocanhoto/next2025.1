"""Objetivo:

Entender como fazer rotas do tipo CRUD, visualizando no /docs o efeito das alterações feitas
em código, aplicando os parâmetros do FastAPI (path, description, response_model, status_code).

CRUD Routes
-----------

GET     /users      Returns the entire array *
GET     /users/:id  Returns an object by its id property
POST    /users      Inserts a new object in the array (autogenerated if not provided)
PUT     /users      Replaces the whole data bucket content
PUT     /users/:id  Performs a full object update by its id (replace)
DELETE  /users      Deletes the data bucket content
DELETE  /users/:id  Deletes an object by its id
PATCH   /users      Concatenates the arrays
PATCH   /users/:id  Performs a partial object update by its id (merge)."""

from enum import StrEnum
from typing import Annotated

from fastapi import FastAPI, HTTPException, status, Depends
from pydantic import BaseModel

from models.user import User
from dao.user import UserDAO
from dependencies.user_dao import get_user_dao

app = FastAPI()


class SortOptions(StrEnum):
    ASC = "asc"
    DESC = "desc"


class UserFields(StrEnum):
    ID = "id"
    USERNAME = "username"
    EMAIL = "email"
    CREATED_AT = "createdAt"


class UserApi(BaseModel):
    id: int
    username: str
    email: str
    createdAt: str


class UserApiRequest(BaseModel):
    username: str
    password: str
    email: str


# GET     /users      Returns the entire array *
@app.get("/users")
async def get_all_users(
    user_dao: Annotated[UserDAO, Depends(get_user_dao)],
    skip: int = 0,
    limit: int = 100,
    sort: SortOptions = SortOptions.ASC,
    sortby: UserFields = UserFields.USERNAME,
) -> list[UserApi]:
    users = user_dao.list_users(
        offset=skip, limit=limit, sort=sort.value, sort_by=sortby.value
    )

    users_api = [
        UserApi(
            id=user.id,
            username=user.username,
            email=user.email,
            createdAt=user.created_at.isoformat(),
        )
        for user in users
    ]

    return users_api


# GET     /users/:id  Returns an object by its id property
@app.get("/users/{user_id}")
async def get_user(
    user_dao: Annotated[UserDAO, Depends(get_user_dao)],
    user_id: int,
) -> UserApi:
    user = user_dao.get_user(user_id)

    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found!",
        )

    return UserApi(
        id=user.id,
        username=user.username,
        email=user.email,
        createdAt=user.created_at.isoformat(),
    )


# POST    /users      Inserts a new object in the array
@app.post("/users", status_code=status.HTTP_201_CREATED)
async def add_user(
    user_dao: Annotated[UserDAO, Depends(get_user_dao)],
    user: UserApiRequest,
) -> UserApi:
    db_user = User(
        username=user.username,
        password=user.password,
        email=user.email,
    )

    try:
        user_dao.add_user(db_user)
    except ValueError as error:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New username or e-mail already exists!",
        ) from error

    return UserApi(
        id=db_user.id,
        username=db_user.username,
        email=db_user.email,
        createdAt=db_user.created_at.isoformat(),
    )


# PUT     /users/3  Performs a full object update by its id (replace)
@app.put("/users/{user_id}")
async def update_user(
    user_dao: Annotated[UserDAO, Depends(get_user_dao)],
    user_id: int,
    user: UserApiRequest,
) -> UserApi:
    try:
        new_db_user = User(
            username=user.username, password=user.password, email=user.email
        )
        db_user = user_dao.update_user(user_id, new_db_user)
    except KeyError as error:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found!",
        ) from error
    except ValueError as error:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New username or e-mail already exists!",
        ) from error

    return UserApi(
        id=user_id,
        username=db_user.username,
        email=db_user.email,
        createdAt=db_user.created_at.isoformat(),
    )


# DELETE  /users/5  Deletes an object by its id
@app.delete("/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(
    user_dao: Annotated[UserDAO, Depends(get_user_dao)],
    user_id: int,
) -> None:
    try:
        user_dao.delete_user(user_id)
    except KeyError as error:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found!",
        ) from error
